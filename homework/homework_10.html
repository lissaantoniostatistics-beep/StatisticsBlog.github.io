<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework 10 - Counting Process Simulation</title>
    <meta name="description" content="Simulation of a counting process with rate lambda, approximation by Bernoulli trials, theoretical analysis.">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/homework.css">
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        .visualization-container {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        canvas {
            border: 1px solid #ddd;
            background: white;
            display: block;
            margin: 10px auto;
            max-width: 100%;
        }
        .chart-title {
            text-align: center;
            font-weight: bold;
            margin: 15px 0 5px 0;
            color: #2c3e50;
        }
        .stats-panel {
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }
        .simulation-panel {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .simulation-panel label {
            display: inline-block;
            margin-right: 15px;
            margin-bottom: 10px;
        }
        .simulation-panel input {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            width: 80px;
        }
        .simulation-panel button {
            padding: 8px 16px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .simulation-panel button:hover {
            background: #2980b9;
        }
    </style>
</head>
<body>
<header class="header">
    <div class="header-content">
        <a href="../index.html" class="logo">Statistica Blog</a>
        <nav class="nav">
            <a href="../index.html" class="nav-link">Home</a>
            <a href="../index.html#homework" class="nav-link">Homework</a>
            <a href="#" class="nav-link">Info</a>
        </nav>
    </div>
</header>

<main class="main-content">
    <nav class="breadcrumb">
        <a href="../index.html">Home</a>
        <span class="breadcrumb-separator">›</span>
        <a href="../index.html#homework">Homework</a>
        <span class="breadcrumb-separator">›</span>
        <span class="breadcrumb-current">Week 6</span>
    </nav>

    <header class="article-header">
        <div class="article-meta">
            <span class="homework-week">Week 6</span>
            <span class="article-date">18 Nov 2025</span>
        </div>
        <h1 class="article-title">Simulation of a Counting Process with Constant Rate \(\lambda\)</h1>
        <div class="article-tags">
            <span class="tag">Stochastic Processes</span>
            <span class="tag">Poisson</span>
            <span class="tag">Simulation</span>
        </div>
    </header>

    <article class="article-content">

<section class="content-section">
    <h2>Objective</h2>
    <p>This assignment simulates a counting process on the interval \([0,T]\) with events occurring independently at a constant rate \(\lambda\). We approximate the process by partitioning the interval into \(n\) small subintervals and performing independent Bernoulli trials with success probability \(\lambda/n\).</p>
</section>

<section class="content-section">
    <h2>Theoretical Background</h2>

    <h3>1. Approximation Scheme</h3>
    <p>Let the time interval be \(T=1\) for simplicity, and split it into \(n\) equal subintervals of length \(1/n\). In each subinterval an event occurs with probability</p>
    <p style="text-align:center">\[p = \frac{\lambda}{n}.\]</p>
    <p>The total number of events is the sum of \(n\) i.i.d. Bernoulli random variables. Thus the simulated count \(N(1)\) follows a Binomial distribution:</p>
    <p style="text-align:center">\[N(1) \sim \mathrm{Binomial}(n, \lambda/n).\]</p>

    <h3>2. Limit as \(n \to \infty\)</h3>
    <p>The classical Poisson limit theorem states:</p>
    <p style="text-align:center">\[\mathrm{Binomial}(n, \lambda/n) \xrightarrow[]{d} \mathrm{Poisson}(\lambda).\]</p>
    <p>Thus the simulated counting process approximates a <strong>Poisson process</strong> with rate \(\lambda\). The increments over disjoint intervals are (approximately) independent and Poisson distributed.</p>

    <h3>3. Interpretation of the Rate Parameter</h3>
    <p>The parameter \(\lambda\) is the expected number of events per unit time:</p>
    <p style="text-align:center">\[\mathbb{E}[N(t)] = \lambda t.\]</p>
    <p>It governs both the mean and variance of increments:</p>
    <p style="text-align:center">\[\mathrm{Var}(N(t)) = \lambda t.\]</p>
</section>

<section class="content-section">
    <h2>Interactive Simulation</h2>
    <p>Use the controls below to simulate counting process trajectories and analyze their distribution.</p>

    <div class="simulation-panel">
        <label>Rate λ: <input id="lambdaInput" type="number" value="5" step="0.1" min="0.1"></label>
        <label>n (subintervals): <input id="nInput" type="number" value="5000" min="100"></label>
        <label>Number of trajectories: <input id="numTrajInput" type="number" value="10" min="1" max="100"></label>
        <br>
        <button onclick="runSimulation()">Simulate Trajectories</button>
        <button onclick="runDistributionAnalysis()">Analyze Distribution (1000 runs)</button>
    </div>

    <div class="stats-panel">
        <pre id="output" style="margin: 0; font-family: monospace;"></pre>
    </div>

    <div class="visualization-container">
        <div class="chart-title">Sample Trajectories</div>
        <canvas id="trajectoriesCanvas" width="800" height="400"></canvas>
        
        <div class="chart-title">Distribution of Final Counts</div>
        <canvas id="distributionCanvas" width="800" height="400"></canvas>
    </div>
</section>

<section class="content-section">
    <h2>JavaScript Simulation Code</h2>
    <p>The simulation uses vanilla JavaScript to generate sample paths of the counting process.</p>

    <pre class="code-block"><code>// Counting process simulation
function simulateCountingProcess(lambda = 5, n = 5000) {
    const dt = 1 / n;
    const p = lambda / n;
    let count = 0;
    const times = [0];
    const values = [0];

    for (let i = 1; i <= n; i++) {
        if (Math.random() < p) count++;
        times.push(i * dt);
        values.push(count);
    }

    return { times, values, total: count };
}</code></pre>
</section>

<section class="content-section">
    <h2>Theoretical Properties of the Approximated Process</h2>
    <ul>
        <li><strong>Independent Increments:</strong> Events in disjoint intervals arise from independent Bernoulli trials.</li>
        <li><strong>Stationary Increments:</strong> Each subinterval has the same probability \(\lambda/n\) of containing an event.</li>
        <li><strong>Counting Nature:</strong> The sample path is a step function increasing by jumps of size 1.</li>
        <li><strong>Poisson Limit:</strong> As \(n\to\infty\), the increments converge to Poisson-distributed variables with parameter \(\lambda t\).</li>
    </ul>
</section>

<section class="content-section">
    <h2>Conclusion</h2>
    <p>The simulation demonstrates how a Poisson process emerges from a limit of simple Bernoulli trials over very small intervals. The rate \(\lambda\) controls the expected number of events per unit time and fully characterizes the distribution of increments.</p>
</section>

    </article>
</main>

<script>
// Counting process simulation
function simulateCountingProcess(lambda = 5, n = 5000) {
    const dt = 1 / n;
    const p = lambda / n;
    let count = 0;
    const times = [0];
    const values = [0];

    for (let i = 1; i <= n; i++) {
        if (Math.random() < p) count++;
        times.push(i * dt);
        values.push(count);
    }

    return { times, values, total: count };
}

// Plot multiple trajectories
function plotTrajectories(trajectories, lambda) {
    const canvas = document.getElementById('trajectoriesCanvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Find max value for scaling
    let maxValue = 0;
    trajectories.forEach(traj => {
        maxValue = Math.max(maxValue, Math.max(...traj.values));
    });
    maxValue = Math.max(maxValue, lambda * 1.5); // Ensure expected value line is visible
    
    const padding = 50;
    const plotWidth = width - 2 * padding;
    const plotHeight = height - 2 * padding;
    
    // Draw axes
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, height - padding);
    ctx.lineTo(width - padding, height - padding);
    ctx.stroke();
    
    // Draw axis labels
    ctx.fillStyle = '#333';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Time t', width / 2, height - 15);
    ctx.save();
    ctx.translate(15, height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('N(t)', 0, 0);
    ctx.restore();
    
    // Draw grid and y-axis labels
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    ctx.fillStyle = '#666';
    ctx.textAlign = 'right';
    const numYTicks = 5;
    for (let i = 0; i <= numYTicks; i++) {
        const value = (maxValue / numYTicks) * i;
        const y = height - padding - (plotHeight / numYTicks) * i;
        ctx.beginPath();
        ctx.moveTo(padding, y);
        ctx.lineTo(width - padding, y);
        ctx.stroke();
        ctx.fillText(value.toFixed(1), padding - 10, y + 4);
    }
    
    // Draw x-axis labels
    ctx.textAlign = 'center';
    const numXTicks = 5;
    for (let i = 0; i <= numXTicks; i++) {
        const value = i / numXTicks;
        const x = padding + (plotWidth / numXTicks) * i;
        ctx.fillText(value.toFixed(1), x, height - padding + 20);
    }
    
    // Draw expected value line
    ctx.strokeStyle = '#e74c3c';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    const expectedY = height - padding - (lambda / maxValue) * plotHeight;
    ctx.beginPath();
    ctx.moveTo(padding, expectedY);
    ctx.lineTo(width - padding, expectedY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Label for expected value
    ctx.fillStyle = '#e74c3c';
    ctx.textAlign = 'left';
    ctx.fillText(`E[N(1)] = ${lambda}`, width - padding - 100, expectedY - 5);
    
    // Draw trajectories
    const colors = ['#3498db', '#2ecc71', '#9b59b6', '#f39c12', '#1abc9c', 
                    '#34495e', '#e67e22', '#95a5a6', '#d35400', '#16a085'];
    
    trajectories.forEach((traj, idx) => {
        ctx.strokeStyle = colors[idx % colors.length];
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        
        for (let i = 0; i < traj.times.length; i++) {
            const x = padding + traj.times[i] * plotWidth;
            const y = height - padding - (traj.values[i] / maxValue) * plotHeight;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        ctx.stroke();
    });
    
    ctx.globalAlpha = 1.0;
}

// Plot distribution histogram
function plotDistribution(counts, lambda) {
    const canvas = document.getElementById('distributionCanvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Create histogram
    const histogram = {};
    counts.forEach(count => {
        histogram[count] = (histogram[count] || 0) + 1;
    });
    
    const minCount = Math.min(...counts);
    const maxCount = Math.max(...counts);
    const maxFreq = Math.max(...Object.values(histogram));
    
    const padding = 50;
    const plotWidth = width - 2 * padding;
    const plotHeight = height - 2 * padding;
    
    // Draw axes
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(padding, padding);
    ctx.lineTo(padding, height - padding);
    ctx.lineTo(width - padding, height - padding);
    ctx.stroke();
    
    // Draw axis labels
    ctx.fillStyle = '#333';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Number of Events', width / 2, height - 15);
    ctx.save();
    ctx.translate(15, height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Frequency', 0, 0);
    ctx.restore();
    
    // Draw bars
    const barWidth = plotWidth / (maxCount - minCount + 1);
    ctx.fillStyle = '#3498db';
    
    for (let count = minCount; count <= maxCount; count++) {
        const freq = histogram[count] || 0;
        const barHeight = (freq / maxFreq) * plotHeight;
        const x = padding + (count - minCount) * barWidth;
        const y = height - padding - barHeight;
        
        ctx.fillRect(x + 2, y, barWidth - 4, barHeight);
    }
    
    // Draw theoretical Poisson PMF overlay
    ctx.strokeStyle = '#e74c3c';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    const poissonPMF = (k, lambda) => {
        return Math.exp(-lambda + k * Math.log(lambda) - logFactorial(k));
    };
    
    const logFactorial = (n) => {
        if (n <= 1) return 0;
        let result = 0;
        for (let i = 2; i <= n; i++) {
            result += Math.log(i);
        }
        return result;
    };
    
    for (let count = minCount; count <= maxCount; count++) {
        const theoreticalProb = poissonPMF(count, lambda);
        const theoreticalFreq = theoreticalProb * counts.length;
        const barHeight = (theoreticalFreq / maxFreq) * plotHeight;
        const x = padding + (count - minCount + 0.5) * barWidth;
        const y = height - padding - barHeight;
        
        if (count === minCount) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.stroke();
    
    // Legend
    ctx.fillStyle = '#3498db';
    ctx.fillRect(width - padding - 150, padding + 10, 20, 15);
    ctx.fillStyle = '#333';
    ctx.textAlign = 'left';
    ctx.fillText('Simulated', width - padding - 125, padding + 22);
    
    ctx.strokeStyle = '#e74c3c';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(width - padding - 150, padding + 40);
    ctx.lineTo(width - padding - 130, padding + 40);
    ctx.stroke();
    ctx.fillText('Poisson(λ)', width - padding - 125, padding + 44);
    
    // Y-axis labels
    ctx.fillStyle = '#666';
    ctx.textAlign = 'right';
    const numYTicks = 5;
    for (let i = 0; i <= numYTicks; i++) {
        const freq = (maxFreq / numYTicks) * i;
        const y = height - padding - (plotHeight / numYTicks) * i;
        ctx.fillText(Math.round(freq), padding - 10, y + 4);
    }
    
    // X-axis labels
    ctx.textAlign = 'center';
    const step = Math.max(1, Math.floor((maxCount - minCount) / 10));
    for (let count = minCount; count <= maxCount; count += step) {
        const x = padding + (count - minCount + 0.5) * barWidth;
        ctx.fillText(count, x, height - padding + 20);
    }
}

// Run simulation with trajectory visualization
function runSimulation() {
    const lambda = parseFloat(document.getElementById('lambdaInput').value);
    const n = parseInt(document.getElementById('nInput').value);
    const numTraj = parseInt(document.getElementById('numTrajInput').value);
    
    if (isNaN(lambda) || lambda <= 0) {
        document.getElementById('output').textContent = 'Error: λ must be a positive number';
        return;
    }
    if (isNaN(n) || n <= 0) {
        document.getElementById('output').textContent = 'Error: n must be a positive integer';
        return;
    }
    if (isNaN(numTraj) || numTraj <= 0 || numTraj > 100) {
        document.getElementById('output').textContent = 'Error: Number of trajectories must be between 1 and 100';
        return;
    }
    
    // Generate trajectories
    const trajectories = [];
    const totals = [];
    
    for (let i = 0; i < numTraj; i++) {
        const result = simulateCountingProcess(lambda, n);
        trajectories.push(result);
        totals.push(result.total);
    }
    
    // Calculate statistics
    const mean = totals.reduce((a, b) => a + b, 0) / numTraj;
    const variance = totals.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / numTraj;
    const stdDev = Math.sqrt(variance);
    const min = Math.min(...totals);
    const max = Math.max(...totals);
    
    const expectedValue = lambda;
    const theoreticalStdDev = Math.sqrt(lambda);
    
    document.getElementById('output').textContent = 
        `Simulation Results (${numTraj} trajectories):\n` +
        `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n` +
        `Sample mean:          ${mean.toFixed(3)}\n` +
        `Expected value (λ):   ${expectedValue.toFixed(3)}\n` +
        `Sample std dev:       ${stdDev.toFixed(3)}\n` +
        `Theoretical std dev:  ${theoreticalStdDev.toFixed(3)}\n` +
        `Range:                [${min}, ${max}]`;
    
    // Plot trajectories
    plotTrajectories(trajectories, lambda);
    
    // Plot distribution
    plotDistribution(totals, lambda);
}

// Run distribution analysis with many simulations
function runDistributionAnalysis() {
    const lambda = parseFloat(document.getElementById('lambdaInput').value);
    const n = parseInt(document.getElementById('nInput').value);
    const numSims = 1000;
    
    if (isNaN(lambda) || lambda <= 0 || isNaN(n) || n <= 0) {
        document.getElementById('output').textContent = 'Error: Invalid parameters';
        return;
    }
    
    document.getElementById('output').textContent = 'Running 1000 simulations...';
    
    // Use setTimeout to avoid blocking UI
    setTimeout(() => {
        const totals = [];
        for (let i = 0; i < numSims; i++) {
            const result = simulateCountingProcess(lambda, n);
            totals.push(result.total);
        }
        
        // Calculate statistics
        const mean = totals.reduce((a, b) => a + b, 0) / numSims;
        const variance = totals.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / numSims;
        const stdDev = Math.sqrt(variance);
        const min = Math.min(...totals);
        const max = Math.max(...totals);
        
        const expectedValue = lambda;
        const theoreticalStdDev = Math.sqrt(lambda);
        
        document.getElementById('output').textContent = 
            `Distribution Analysis (${numSims} simulations):\n` +
            `━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n` +
            `Sample mean:          ${mean.toFixed(3)}\n` +
            `Expected value (λ):   ${expectedValue.toFixed(3)}\n` +
            `Difference:           ${Math.abs(mean - expectedValue).toFixed(3)}\n\n` +
            `Sample variance:      ${variance.toFixed(3)}\n` +
            `Theoretical var (λ):  ${lambda.toFixed(3)}\n` +
            `Difference:           ${Math.abs(variance - lambda).toFixed(3)}\n\n` +
            `Sample std dev:       ${stdDev.toFixed(3)}\n` +
            `Theoretical std dev:  ${theoreticalStdDev.toFixed(3)}\n` +
            `Range:                [${min}, ${max}]`;
        
        // Plot distribution
        plotDistribution(totals, lambda);
        
        // Clear trajectories canvas
        const canvas = document.getElementById('trajectoriesCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#666';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Run "Simulate Trajectories" to see sample paths', canvas.width / 2, canvas.height / 2);
    }, 100);
}

// Initialize
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('output').textContent = 
        'Click "Simulate Trajectories" to see sample paths\n' +
        'or "Analyze Distribution" to run 1000 simulations';
});
</script>

</body>
</html>