<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework 11 - SDE Simulation with Euler-Maruyama</title>
    <meta name="description" content="Simulation of stochastic differential equations using Euler-Maruyama method, application to Wiener process and general SDEs.">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="../css/homework.css">
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        .visualization-container {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        canvas {
            border: 1px solid #ddd;
            background: white;
            display: block;
            margin: 10px auto;
            max-width: 100%;
        }
        .chart-title {
            text-align: center;
            font-weight: bold;
            margin: 15px 0 5px 0;
            color: #2c3e50;
        }
        .stats-panel {
            background: white;
            padding: 15px;
            border-radius: 5px;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }
        .simulation-panel {
            background: #e8f4f8;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        .simulation-panel label {
            display: inline-block;
            margin-right: 15px;
            margin-bottom: 10px;
        }
        .simulation-panel input, .simulation-panel select {
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            width: 120px;
        }
        .simulation-panel button {
            padding: 8px 16px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .simulation-panel button:hover {
            background: #2980b9;
        }
        .sde-info {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px;
            margin: 15px 0;
            font-family: monospace;
            font-size: 14px;
        }
    </style>
</head>
<body>
<header class="header">
    <div class="header-content">
        <a href="../index.html" class="logo">Statistica Blog</a>
        <nav class="nav">
            <a href="../index.html" class="nav-link">Home</a>
            <a href="../index.html#homework" class="nav-link">Homework</a>
            <a href="#" class="nav-link">Info</a>
        </nav>
    </div>
</header>

<main class="main-content">
    <nav class="breadcrumb">
        <a href="../index.html">Home</a>
        <span class="breadcrumb-separator">›</span>
        <a href="../index.html#homework">Homework</a>
        <span class="breadcrumb-separator">›</span>
        <span class="breadcrumb-current">Week 7</span>
    </nav>

    <header class="article-header">
        <div class="article-meta">
            <span class="homework-week">Week 7</span>
            <span class="article-date">25 Nov 2025</span>
        </div>
        <h1 class="article-title">Stochastic Differential Equations: Euler-Maruyama Method</h1>
        <div class="article-tags">
            <span class="tag">Stochastic Processes</span>
            <span class="tag">Euler-Maruyama</span>
            <span class="tag">SDE</span>
        </div>
    </header>

    <article class="article-content">

<section class="content-section">
    <h2>Objective</h2>
    <p>This assignment implements the <strong>Euler-Maruyama method</strong> to numerically solve stochastic differential equations (SDEs). We apply it to simulate the Wiener process (Brownian motion) and extend it to handle more general SDEs including Ornstein-Uhlenbeck and Geometric Brownian Motion processes.</p>
</section>

<section class="content-section">
    <h2>Theoretical Background</h2>

    <h3>1. Stochastic Differential Equations</h3>
    <p>A general SDE has the form:</p>
    <p style="text-align:center">\[dX_t = \mu(X_t, t)\, dt + \sigma(X_t, t)\, dW_t\]</p>
    <p>where:</p>
    <ul>
        <li>\(\mu(X_t, t)\) is the <strong>drift coefficient</strong> (deterministic trend)</li>
        <li>\(\sigma(X_t, t)\) is the <strong>diffusion coefficient</strong> (stochastic volatility)</li>
        <li>\(W_t\) is a standard Wiener process</li>
    </ul>

    <h3>2. Euler-Maruyama Discretization</h3>
    <p>The Euler-Maruyama method discretizes the SDE over small time steps \(\Delta t = T/n\):</p>
    <p style="text-align:center">\[X_{i+1} = X_i + \mu(X_i, t_i)\Delta t + \sigma(X_i, t_i)\sqrt{\Delta t}\, Z_i\]</p>
    <p>where \(Z_i \sim N(0,1)\) are independent standard normal random variables generated via the Box-Muller transform.</p>

    <h3>3. Wiener Process (Brownian Motion)</h3>
    <p>For a standard Wiener process with volatility parameter \(\sigma\):</p>
    <p style="text-align:center">\[dB_t = \sigma\, dW_t\]</p>
    <p>This corresponds to \(\mu(X_t, t) = 0\) and \(\sigma(X_t, t) = \sigma\) (constant). The discretization becomes:</p>
    <p style="text-align:center">\[B_{i+1} = B_i + \sigma\sqrt{\Delta t}\, Z_i\]</p>

    <h3>4. Examples of General SDEs</h3>
    <p><strong>Ornstein-Uhlenbeck Process</strong> (mean-reverting):</p>
    <p style="text-align:center">\[dX_t = \theta(\mu - X_t)dt + \sigma dW_t\]</p>
    <p>Models processes that tend to revert to a long-term mean \(\mu\) with speed \(\theta\).</p>

    <p><strong>Geometric Brownian Motion</strong> (used in finance):</p>
    <p style="text-align:center">\[dX_t = \mu X_t dt + \sigma X_t dW_t\]</p>
    <p>Models stock prices and other quantities that cannot become negative.</p>
</section>

<section class="content-section">
    <h2>Interactive Simulation</h2>
    <p>Select an SDE type and adjust parameters to simulate different stochastic processes.</p>

    <div class="simulation-panel">
        <label>SDE Type: 
            <select id="sdeType" onchange="updateSdeInfo()">
                <option value="wiener">Wiener Process</option>
                <option value="ou">Ornstein-Uhlenbeck</option>
                <option value="gbm">Geometric Brownian Motion</option>
            </select>
        </label>
        <br>
        <div id="parametersDiv">
            <label>σ (volatility): <input id="sigmaInput" type="number" value="1" step="0.1" min="0.1"></label>
        </div>
        <label>X₀ (initial value): <input id="x0Input" type="number" value="0" step="0.1"></label>
        <label>T (time horizon): <input id="TInput" type="number" value="1" step="0.1" min="0.1"></label>
        <label>n (time steps): <input id="nInput" type="number" value="1000" min="100"></label>
        <label>Number of paths: <input id="numTrajInput" type="number" value="10" min="1" max="100"></label>
        <br>
        <button onclick="runSimulation()">Simulate Paths</button>
        <button onclick="runDistributionAnalysis()">Analyze Distribution (1000 runs)</button>
    </div>

    <div class="sde-info" id="sdeInfo">
        dB<sub>t</sub> = σ dW<sub>t</sub>
    </div>

    <div class="stats-panel">
        <pre id="output" style="margin: 0; font-family: monospace;"></pre>
    </div>

    <div class="visualization-container">
        <div class="chart-title">Sample Paths</div>
        <canvas id="trajectoriesCanvas" width="800" height="400"></canvas>
        
        <div class="chart-title">Distribution of Final Values X(T)</div>
        <canvas id="distributionCanvas" width="800" height="400"></canvas>
    </div>
</section>

<section class="content-section">
    <h2>JavaScript Implementation</h2>
    <p>The Euler-Maruyama simulator is implemented as a general framework accepting drift and diffusion functions.</p>

    <pre class="code-block"><code>// Box-Muller transform for standard normal variables
function boxMuller() {
    const u1 = Math.random();
    const u2 = Math.random();
    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
}

// Euler-Maruyama method for general SDEs
function eulerMaruyama(mu, sigma, X0, T, n) {
    const dt = T / n;
    const sqrtDt = Math.sqrt(dt);
    let X = X0;
    const times = [0];
    const values = [X0];

    for (let i = 0; i < n; i++) {
        const t = i * dt;
        const dW = sqrtDt * boxMuller();
        X = X + mu(X, t) * dt + sigma(X, t) * dW;
        times.push((i + 1) * dt);
        values.push(X);
    }

    return { times, values, final: X };
}</code></pre>
</section>

<section class="content-section">
    <h2>Properties of the Method</h2>
    <ul>
        <li><strong>Convergence:</strong> The Euler-Maruyama method converges with strong order 0.5 and weak order 1.0 as \(\Delta t \to 0\)</li>
        <li><strong>Generality:</strong> Works for any SDE by specifying appropriate \(\mu\) and \(\sigma\) functions</li>
        <li><strong>Simplicity:</strong> Extension of deterministic Euler method to stochastic setting</li>
        <li><strong>Limitation:</strong> Requires small time steps for accuracy; higher-order methods exist (Milstein, Runge-Kutta)</li>
    </ul>
</section>

<section class="content-section">
    <h2>Conclusion</h2>
    <p>The Euler-Maruyama method provides a practical numerical approach to simulate stochastic differential equations. By discretizing time and approximating the Wiener process increments with normal random variables, we can generate sample paths for a wide variety of stochastic processes including the Wiener process, mean-reverting processes, and geometric Brownian motion used in financial modeling.</p>
</section>

    </article>
</main>

<script>
    function plotTrajectories(trajectories, type, p, X0, T) {
    const canvas = document.getElementById("trajectoriesCanvas");
    const ctx = canvas.getContext("2d");

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const W = canvas.width;
    const H = canvas.height;

    // All values in all paths
    const allValues = trajectories.flatMap(t => t.values);
    const minY = Math.min(...allValues);
    const maxY = Math.max(...allValues);

    const scaleX = W / trajectories[0].times.length;
    const scaleY = H / (maxY - minY || 1);

    ctx.lineWidth = 1;

    trajectories.forEach(traj => {
        ctx.beginPath();
        ctx.strokeStyle = "rgba(0, 80, 180, 0.7)";

        traj.values.forEach((v, i) => {
            const x = i * scaleX;
            const y = H - (v - minY) * scaleY;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        });

        ctx.stroke();
    });
}
function plotDistribution(finals, type, p, X0, T) {
    const canvas = document.getElementById("distributionCanvas");
    const ctx = canvas.getContext("2d");

    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const W = canvas.width;
    const H = canvas.height;

    // Histogram bins
    const bins = 40;
    const minX = Math.min(...finals);
    const maxX = Math.max(...finals);
    const binWidth = (maxX - minX) / bins;

    const counts = new Array(bins).fill(0);

    finals.forEach(x => {
        const idx = Math.min(Math.floor((x - minX) / binWidth), bins - 1);
        counts[idx]++;
    });

    const maxCount = Math.max(...counts);
    const barWidth = W / bins;

    // Draw histogram
    ctx.fillStyle = "rgba(180, 50, 50, 0.7)";
    counts.forEach((c, i) => {
        const x = i * barWidth;
        const h = (c / maxCount) * H;
        const y = H - h;
        ctx.fillRect(x, y, barWidth - 1, h);
    });

    // ---- GAUSSIANA ----
    const mean = finals.reduce((a, b) => a + b, 0) / finals.length;
    const variance = finals.reduce((a, b) => a + (b - mean)**2, 0) / finals.length;
    const sigma = Math.sqrt(variance);

    function gaussian(x) {
        return (1 / (sigma * Math.sqrt(2 * Math.PI))) * Math.exp(-0.5 * ((x - mean) / sigma)**2);
    }

    // Find max gaussian density to scale to canvas height
    const xs = [];
    for (let i = 0; i < 400; i++) xs.push(minX + (i / 399) * (maxX - minX));
    const gVals = xs.map(gaussian);
    const maxG = Math.max(...gVals);

    ctx.strokeStyle = "blue";
    ctx.lineWidth = 2;
    ctx.beginPath();

    xs.forEach((xVal, i) => {
        const nx = ((xVal - minX) / (maxX - minX)) * W;
        const ny = H - (gaussian(xVal) / maxG) * H;

        if (i === 0) ctx.moveTo(nx, ny);
        else ctx.lineTo(nx, ny);
    });

    ctx.stroke();
}

// Box-Muller transform
function boxMuller() {
    const u1 = Math.random();
    const u2 = Math.random();
    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
}

// Euler–Maruyama method
function eulerMaruyama(mu, sigma, X0, T, n) {
    const dt = T / n;
    const sqrtDt = Math.sqrt(dt);
    let X = X0;

    const times = [0];
    const values = [X0];

    for (let i = 0; i < n; i++) {
        const t = i * dt;
        const dW = sqrtDt * boxMuller();
        X = X + mu(X, t) * dt + sigma(X, t) * dW;
        times.push((i + 1) * dt);
        values.push(X);
    }
    return { times, values, final: X };
}

// SDE definitions
const sdeDefinitions = {
    wiener: {
        name: "Wiener Process",
        equation: "dB<sub>t</sub> = σ dW<sub>t</sub>",
        mu: () => 0,
        sigma: (X, t, p) => p.sigma,
        params: ["sigma"],
        theoreticalMean: (X0) => X0,
        theoreticalVar: (X0, T, p) => p.sigma * p.sigma * T
    },
    ou: {
        name: "Ornstein-Uhlenbeck",
        equation: "dX<sub>t</sub> = θ(μ - X<sub>t</sub>)dt + σ dW<sub>t</sub>",
        mu: (X, t, p) => p.theta * (p.mean - X),
        sigma: (X, t, p) => p.sigma,
        params: ["theta", "mean", "sigma"],
        theoreticalMean: (X0, T, p) =>
            p.mean + (X0 - p.mean) * Math.exp(-p.theta * T),
        theoreticalVar: (X0, T, p) =>
            (p.sigma * p.sigma / (2 * p.theta)) *
            (1 - Math.exp(-2 * p.theta * T))
    },
    gbm: {
        name: "Geometric Brownian Motion",
        equation: "dX<sub>t</sub> = μ X<sub>t</sub> dt + σ X<sub>t</sub> dW<sub>t</sub>",
        mu: (X, t, p) => p.mu * X,
        sigma: (X, t, p) => p.sigma * X,
        params: ["mu", "sigma"],
        theoreticalMean: (X0, T, p) => X0 * Math.exp(p.mu * T),
        theoreticalVar: (X0, T, p) =>
            X0 * X0 * Math.exp(2 * p.mu * T) *
            (Math.exp(p.sigma * p.sigma * T) - 1)
    }
};

function updateSdeInfo() {
    const sdeType = document.getElementById("sdeType").value;
    const sde = sdeDefinitions[sdeType];

    document.getElementById("sdeInfo").innerHTML = sde.equation;

    const div = document.getElementById("parametersDiv");
    if (sdeType === "wiener") {
        div.innerHTML =
            '<label>σ: <input id="sigmaInput" type="number" value="1" step="0.1"></label>';
    } else if (sdeType === "ou") {
        div.innerHTML = `
            <label>θ: <input id="thetaInput" type="number" value="1" step="0.1"></label>
            <label>μ: <input id="meanInput" type="number" value="0" step="0.1"></label>
            <label>σ: <input id="sigmaInput" type="number" value="0.5" step="0.1"></label>`;
    } else {
        div.innerHTML = `
            <label>μ: <input id="muInput" type="number" value="0.1" step="0.1"></label>
            <label>σ: <input id="sigmaInput" type="number" value="0.2" step="0.1"></label>`;
    }
}

function getParameters() {
    const type = document.getElementById("sdeType").value;
    const p = {};

    if (type === "wiener") {
        p.sigma = parseFloat(document.getElementById("sigmaInput").value);
    } else if (type === "ou") {
        p.theta = parseFloat(document.getElementById("thetaInput").value);
        p.mean = parseFloat(document.getElementById("meanInput").value);
        p.sigma = parseFloat(document.getElementById("sigmaInput").value);
    } else {
        p.mu = parseFloat(document.getElementById("muInput").value);
        p.sigma = parseFloat(document.getElementById("sigmaInput").value);
    }
    return p;
}

// ----------------------------------------------------
// PLOTTING FUNCTIONS
// ----------------------------------------------------
// (unchanged from your version; avoided editing for brevity)
// ----------------------------------------------------

/* ... QUI RESTANO plotTrajectories(...) e plotDistribution(...) identici ... */

// ----------------------------------------------------
// SIMULATION
// ----------------------------------------------------

function runSimulation() {
    const type = document.getElementById("sdeType").value;
    const p = getParameters();
    const X0 = parseFloat(document.getElementById("x0Input").value);
    const T = parseFloat(document.getElementById("TInput").value);
    const n = parseInt(document.getElementById("nInput").value);
    const N = parseInt(document.getElementById("numTrajInput").value);

    if (!T || !n || !N || N < 1) {
        document.getElementById("output").textContent = "Invalid parameters.";
        return;
    }

    const sde = sdeDefinitions[type];
    const mu = (X, t) => sde.mu(X, t, p);
    const sigma = (X, t) => sde.sigma(X, t, p);

    const finals = [];
    const trajectories = [];

    for (let i = 0; i < N; i++) {
        const r = eulerMaruyama(mu, sigma, X0, T, n);
        trajectories.push(r);
        finals.push(r.final);
    }

    const mean = finals.reduce((a, b) => a + b, 0) / N;
    const variance = finals.reduce((s, x) => s + (x - mean) ** 2, 0) / N;

    let txt = `Simulation (${N} paths)\n`;
    txt += `Mean: ${mean.toFixed(4)}\n`;
    txt += `Variance: ${variance.toFixed(4)}\n`;

    if (sde.theoreticalMean) {
        txt += `Theo mean: ${sde.theoreticalMean(X0, T, p).toFixed(4)}\n`;
        txt += `Theo var: ${sde.theoreticalVar(X0, T, p).toFixed(4)}\n`;
    }

    document.getElementById("output").textContent = txt;

    plotTrajectories(trajectories, type, p, X0, T);
    plotDistribution(finals, type, p, X0, T);
}


// ----------------------------------------------------
// DISTRIBUTION ANALYSIS
// ----------------------------------------------------

function runDistributionAnalysis() {
    const type = document.getElementById("sdeType").value;
    const p = getParameters();
    const X0 = parseFloat(document.getElementById("x0Input").value);
    const T = parseFloat(document.getElementById("TInput").value);
    const n = parseInt(document.getElementById("nInput").value);

    const sde = sdeDefinitions[type];
    const mu = (X, t) => sde.mu(X, t, p);
    const sigma = (X, t) => sde.sigma(X, t, p);

    const N = 1000;
    const finals = [];

    for (let i = 0; i < N; i++) {
        finals.push(eulerMaruyama(mu, sigma, X0, T, n).final);
    }

    plotDistribution(finals, type, p, X0, T);

    const mean = finals.reduce((a, b) => a + b, 0) / N;
    const variance = finals.reduce((s, x) => s + (x - mean) ** 2, 0) / N;

    let txt = `Distribution Analysis (1000 runs)\n`;
    txt += `Mean: ${mean.toFixed(4)}\nVariance: ${variance.toFixed(4)}\n`;

    if (sde.theoreticalMean) {
        txt += `Theo mean: ${sde.theoreticalMean(X0, T, p).toFixed(4)}\n`;
        txt += `Theo var: ${sde.theoreticalVar(X0, T, p).toFixed(4)}\n`;
    }

    document.getElementById("output").textContent = txt;
}

// Initialize
updateSdeInfo();
</script>
</body>
</html>